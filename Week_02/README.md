# GC性能分析实验

标签（空格分隔）： 未分类

---
## 一、实验分析
### 1、SerialGC
#### -Xms128M -Xmx128M
minorGC时长0.01s，首先会先进行minorGC，分析第一次minorGC，将新生代的垃圾进行收集，存活的对象放到survivor区。在进行了6次minorGC，每次minorGC都可以把新生代清理的很干净，整个堆的大小也不断上升。终于第7次GC的时候开始进行FullGC，此时新生代的回收时间都很短，说明主要工作在老年代，最后又经历了多次fullGC，整个堆的可用大小越来越小，说明老年代也满了，最后抛出了OOM异常，结果显示eden 使用率100%， s0使用了94%，s1使用0%， 老年代使用了99%

> 分析：第一次minorGC的时候发现老年代就有东西，查阅资料知道，有两种情况会直接分配老年代，一种在新生代分配失败且对象是一个不含任何对象引用的大数组，可被直接分配到老年代，通过在老年代的分配避免新生代的一次垃圾回收。另一种情况是配置了PretenureSizeThreshold参数，比这个大的对象都会直接在老年代分配。但是没有配置XX:PretenureSizeThreshold参数，也就是默认值为0，所以都会尽量尝试在新生代分配内存，此时老年代的对象应该是新生代内存分配失败的不含任何引用的大数组

#### -Xms512M -Xmx512M
**生成对象7355次** minorGC时长0.05s， majorGC时长0.06s 经历了8次minorGC，每次GC都把新生代清理得很干净，堆使用的总内存也逐步上升，第9次的时候进行了一次majorGC，新生代基本没有清理，老年代清理了60M左右，第10-11次又经过了两次minorGC，随后经历了3次majorGC后程序执行结束，最后eden使用率4%，s0和s1都是0%，老年代使用87%，整个程序执行没有出现fullGC也没有出现OOM，不过从堆的使用情况来看，堆使用的是越来越多的，运行时间加长一点肯定会出现fullGC和OOM

#### -Xms2048M -Xmx2048M
**生成对象8568次**，minorGC时长0.1s，最后一次0.15s，只经历4次minorGC，最终eden使用率12%，s0使用率100%，s1使用率0%，老年代使用率33%，可以看到在1s的执行中内存的使用情况是没有任何压力的，还有一点是随着内存分配的增加，单次GC的时间越来越长了，和内存分配的比例大致相当

---

### 二、ParallelGC
#### -Xms128M -Xmx128M
gc时长大概0.01s 经过了9次minorGC，进行了17次FullGC后出现了OOM，基本情形和串形GC类似，eden使用率99%，s0和s1为0，老年代使用了99%
#### -Xms512M -Xmx512M
**生产对象8173**个，minorGC时长0.01-0.02s， fullGC时长在0.03-0.04s左右，先进行了11次minorGC，然后进行fullGC，然后两种GC穿插进行，最后都在执行fullGC，最终eden使用21%，老年代使用率92%，看得出来并行GC的GC时间比串行GC少了一些，并且生成的对象数量多了一些

#### -Xms2048M -Xmx2048M
**生产对象11000**个左右，gc时长0.05s左右，最后一次0.16，进行了了6次minorGC, 最终eden使用4%，老年代使用43%

---

### 三、ConcMarkSweepGC
#### -Xms128M -Xmx128M
minorGC使用的是parNew，时长大概0.01s，经历了5次minorGC后开始CMS，大概看到了几个过程：初始标记（0.0002）-->并发标记（0.001）-->并发预清理（0）-->重新标记(0.0015)-->并发清除(0)-->并发重置(0), 整个过程经历了0.014，随后开始进行fullGC，最后发生了OOM，eden区使用100%，老年代使用99%

> 网上查资料，整理了下CMS的几个阶段的工作：
> 
> 1. 初始标记 ：在这个阶段，需要虚拟机停顿正在执行的任务，官方的叫法STW(Stop The Word)。这个过程从垃圾回收的"根对象"开始，只扫描到能够和"根对象"直接关联的对象，并作标记。所以这个过程虽然暂停了整个JVM，但是很快就完成了。
> 
> 2. 并发标记 ：这个阶段紧随初始标记阶段，在初始标记的基础上继续向下追溯标记。并发标记阶段，应用程序的线程和并发标记的线程并发执行，所以用户不会感受到停顿。
> 
> 3. 并发预清理 ：并发预清理阶段仍然是并发的。在这个阶段，虚拟机查找在执行并发标记阶段新进入老年代的对象(可能会有一些对象从新生代晋升到老年代，
> 或者有一些对象被分配到老年代)。通过重新扫描，减少下一个阶段"重新标记"的工作，因为下一个阶段会Stop The World。
> 
> 4. 重新标记 ：这个阶段会暂停虚拟机，收集器线程扫描在CMS堆中剩余的对象。扫描从"跟对象"开始向下追溯，并处理对象关联。
> 
> 5. 并发清理 ：清理垃圾对象，这个阶段收集器线程和应用程序线程并发执行。
> 
> 6. 并发重置 ：这个阶段，重置CMS收集器的数据结构，等待下一次垃圾回收。

#### -Xms512M -Xmx512M
**生产对象9000**个左右，cmsGC时间大概0.05左右，eden区使用4%，老年代使用了98%

#### -Xms2048M -Xmx2048M
**生成对象9500**个左右， 平均minorGC时间0.06，全部都是进行新生代的垃圾回收，并没有经过老年代的垃圾回收，全部都是ParNew，其实这里使用的都是新生代的回收，导致CMS没有真正的使用到，最终eden使用30%，老年代使用38%

---
### 四、G1GC
#### -Xms128M -Xmx128M
发生了OOM
#### -Xms512M -Xmx512M
生产对象平均9300个左右

#### -Xms2048M -Xmx2048M
生产对象在8000-11000个，跳跃浮动比较大

## 二、总结
1. 并行GC的效率在各个时期几乎都比串行GC更好
2. CMS算法通过对GC进行分步进行，相对于并行GC确实可以减少一定的GC的时间，从而提高系统吞吐量

## 三、问题
1. G1不知道是不是我实验的场景内存配太小了，感觉优势并不明显，在和CMS以及并行GC的时候性能感觉差不多